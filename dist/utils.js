function debug_log(msg) {
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/debug/log", false);
    xhttp.setRequestHeader("Content-type", "text/html");
    xhttp.send(msg);
    console.log(msg);
}

function debug_bin(name, data) {
    var view = new Uint8Array(data);
    var xhttp = new XMLHttpRequest();
    xhttp.open("POST", "/debug/file", false);
    xhttp.setRequestHeader("Content-type", "application/octet-stream");
    xhttp.setRequestHeader("Content-Disposition", name);
    xhttp.send(view);
}

// The following functions are taken from https://github.com/saelo/jscpwn/:
//  hex, hexlify, unhexlify, hexdump
//  Copyright (c) 2016 Samuel Gro√ü

// Return the hexadecimal representation of the given byte.
function hex(b) {
    return ('0' + b.toString(16)).substr(-2);
}

// Return the hexadecimal representation of the given byte array.
function hexlify(bytes) {
    var res = [];
    for (var i = 0; i < bytes.length; i++)
        res.push(hex(bytes[i]));

    return res.join('');
}

// Return the binary data represented by the given hexdecimal string.
function unhexlify(hexstr) {
    if (hexstr.length % 2 == 1)
        throw new TypeError("Invalid hex string");

    var bytes = new Uint8Array(hexstr.length / 2);
    for (var i = 0; i < hexstr.length; i += 2)
        bytes[i / 2] = parseInt(hexstr.substr(i, 2), 16);

    return bytes;
}

function hexdump(data) {
    if (typeof data.BYTES_PER_ELEMENT !== 'undefined')
        data = Array.from(data);

    var lines = [];
    for (var i = 0; i < data.length; i += 16) {
        var chunk = data.slice(i, i + 16);
        var parts = chunk.map(hex);
        if (parts.length > 8)
            parts.splice(8, 0, ' ');
        lines.push(parts.join(' '));
    }

    return lines.join('\n');
}

var Struct = (function() {
    // Allocate these once to avoid unecessary heap allocations during pack/unpack operations.
    var buffer      = new ArrayBuffer(8);
    var byteView    = new Uint8Array(buffer);
    var uint16View  = new Uint16Array(buffer);
    var uint32View  = new Uint32Array(buffer);
    var float64View = new Float64Array(buffer);

    return {
        pack: function(type, value, high) {
            if(type === "int64")
            {
                var res = new Uint8Array(8);
                res.set(this.pack(this.int32, high), 4);
                res.set(this.pack(this.int32, value), 0);
                return res;
            }
            var view = type;        // See below
            view[0] = value;
            return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT);
        },

        unpack: function(type, bytes) {
            if(type === "int64")
            {
                throw new Error("don't unpack as int64");
                return this.unpack(this.int32, bytes.slice(0, 4)) + (this.unpack(this.int32, bytes.slice(4, 8)) << 32)
            }
            if (bytes.length !== type.BYTES_PER_ELEMENT)
                throw Error("Invalid bytearray");

            var view = type;        // See below
            byteView.set(bytes);
            //debug_log(view);
            return view[0];
        },

        // Available types.
        int8:    byteView,
        int16:   uint16View,
        int32:   uint32View,
        int64:   "int64",
        float64: float64View
    };
})();
